<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>NumPy — Phase 1 &amp; 2: Complete Learning Notes (1–26)</title>
<style>
:root {
  --text-color: #222;
  --heading-color: #003366;
  --code-bg: #f4f4f4;
  --code-text: #c7254e;
  --note-bg: #f9f9f9;
  --note-border: #ccc;
  --bg-color: #fff;
}

[data-theme="dark"] {
  --text-color: #6468d0;
  --heading-color: #66aaff;
  --code-bg: #222;
  --code-text: #d6b471;
  --note-bg: #333;
  --note-border: #666;
  --bg-color: #111;
}

body {
  color: var(--text-color);
  background: var(--bg-color);
  margin: 0;
  line-height: 1.6;
  font-family: system-ui, sans-serif;
  transition: background 0.3s, color 0.3s;
}

.container, .wrap {
  max-width: 900px;
  margin: auto;
  padding: 2rem;
}

.subtitle {
  font-size: 1rem;
  color: gray;
  margin-top: 0.5rem;
}

.muted {
  color: gray;
  font-size: 0.9rem;
}

.tip {
  background: #e6f7ff;
  border-left: 5px solid #33aaff;
  margin: 1rem 0;
  padding: 1rem;
  border-radius: 6px;
}

.example {
  background: #fafafa;
  border: 1px solid #ddd;
  padding: 1rem;
  border-radius: 6px;
  margin: 1rem 0;
}

h1, h2, h3 {
  color: var(--heading-color);
  margin-top: 2rem;
}

h1 {
  font-size: 2rem;
  border-bottom: 2px solid var(--heading-color);
  padding-bottom: 0.5rem;
}

h2 {
  font-size: 1.5rem;
  margin-top: 1.5rem;
}

h3 {
  font-size: 1.2rem;
  margin-top: 1rem;
}

pre {
  background: var(--code-bg);
  padding: 1rem;
  border-radius: 8px;
  overflow-x: auto;
}

code {
  font-family: 'Fira Code', monospace;
  color: var(--code-text);
}

ul, ol {
  padding-left: 1.5rem;
}

blockquote {
  background: var(--note-bg);
  border-left: 5px solid var(--note-border);
  margin: 1rem 0;
  padding: 1rem;
  border-radius: 6px;
}

.toggle-btn {
  position: fixed;
  top: 1rem;
  right: 1rem;
  background: var(--heading-color);
  color: #fff;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  cursor: pointer;
  font-weight: bold;
}
</style>
</head>
<body>
  <button class="toggle-btn" onclick="toggleTheme()">🌙 Dark</button>
  <div class="wrap">
    <header>
      <div>
        <h1>NumPy — Phase 1 &amp; 2: Complete Learning Notes (Beginner → Advanced)</h1>
        <div class="subtitle">Friendly, step-by-step master-notes combining Phases 1 &amp; 2: theory, examples, mini-challenges, pitfalls, and tips.</div>
      </div>
    </header>

    <nav class="toc" aria-label="Table of contents">
      <strong>Table of contents</strong>
      <ol>
        <li><a href="#s1">Motivation: Why NumPy?</a></li>
        <li><a href="#s2">Setup &amp; Import</a></li>
        <li><a href="#s3">Arrays vs Python lists</a></li>
        <li><a href="#s4">Creating Arrays</a></li>
        <li><a href="#s5">Array attributes</a></li>
        <li><a href="#s6">Vector / Matrix / Tensor</a></li>
        <li><a href="#s7">Indexing &amp; Slicing</a></li>
        <li><a href="#s8">Boolean masking &amp; filtering</a></li>
        <li><a href="#s9">Fancy indexing</a></li>
        <li><a href="#s10">Broadcasting</a></li>
        <li><a href="#s11">Universal functions (ufuncs)</a></li>
        <li><a href="#s12">Aggregation &amp; axis</a></li>
        <li><a href="#s13">Reshaping &amp; transpose</a></li>
        <li><a href="#s14">Concatenate, stack, split</a></li>
        <li><a href="#s15">Sorting, argsort, searchsorted</a></li>
        <li><a href="#s16">np.where &amp; conditional assignment</a></li>
        <li><a href="#s17">Copy vs View &amp; performance tips</a></li>
        <li><a href="#s18">Random numbers &amp; reproducibility</a></li>
        <li><a href="#s19">Linear algebra basics</a></li>
        <li><a href="#s20">Practical mini-projects &amp; exercises</a></li>
        <li><a href="#s21">Quick reference &amp; cheat-sheet</a></li>
        <li><a href="#s22">Further reading &amp; next steps</a></li>
        <li><a href="#s23">Advanced topics</a></li>
        <li><a href="#s24">Working with real-world data</a></li>
        <li><a href="#s25">Performance tuning &amp; memory efficiency</a></li>
        <li><a href="#s26">Final challenges &amp; projects</a></li>
      </ol>
    </nav>

    <section id="s1">
      <h2>1. Motivation: Why NumPy?</h2>
      <p>NumPy (Numerical Python) provides fast, memory-efficient arrays and a large library of vectorized operations. Key benefits over pure Python lists:</p>
      <ul>
        <li>Speed — C-backed implementations make numeric ops much faster.</li>
        <li>Compact memory — homogeneous dtype and contiguous arrays.</li>
        <li>Broadcasting and ufuncs — concise math without Python loops.</li>
        <li>Interop — foundation for pandas, scikit-learn, TensorFlow, and more.</li>
      </ul>
      <div class="tip">If you do numeric computing in Python, NumPy should be your first tool. When you see slow Python loops over large lists, think NumPy.</div>
    </section>

    <section id="s2">
      <h2>2. Setup &amp; Import</h2>
      <p><strong>Install (if needed):</strong></p>
      <pre><code>pip install numpy</code></pre>
      <p><strong>Import:</strong></p>
      <pre><code>import numpy as np</code></pre>
      <p class="muted">Tip: <code>np</code> is the standard alias — use it to make your code familiar to others.</p>
    </section>

    <section id="s3">
      <h2>3. Arrays vs Python lists (short theory)</h2>
      <p>Python lists are flexible containers (mixed types allowed) but are slow for numeric computation. NumPy arrays are homogeneous — same dtype — which allows efficient memory layout and fast C-level loops.</p>
      <div class="example">
        <div class="muted">Example — list vs NumPy elementwise multiply:</div>
        <pre><code># Python list
lst = [1, 2, 3]
print(lst * 2)   # -> [1, 2, 3, 1, 2, 3]

# NumPy array (element-wise)
import numpy as np
arr = np.array([1,2,3])
print(arr * 2)   # -> array([2, 4, 6])</code></pre>
      </div>
      <div class="tip">Mini-challenge: multiply two lists elementwise without NumPy (use a loop) and then with NumPy — compare clarity and performance.</div>
    </section>

    <section id="s4">
      <h2>4. Creating Arrays (many ways)</h2>
      <p>Several constructors exist for different use-cases.</p>
      <div class="example">
        <div class="muted">From Python structures</div>
        <pre><code>a = np.array([1,2,3])            # 1D
b = np.array([[1,2,3],[4,5,6]])  # 2D</code></pre>
        <div class="muted">Range-like builders</div>
        <pre><code>np.arange(0,10,2)    # [0,2,4,6,8]
np.linspace(0,1,5)   # 5 evenly spaced numbers between 0 and 1</code></pre>
        <div class="muted">Convenience constructors</div>
        <pre><code>np.zeros((3,4))
np.ones((2,2))
np.eye(4)
np.empty((2,3))  # uninitialized (fast)</code></pre>
        <div class="muted">Random arrays</div>
        <pre><code>np.random.seed(0)
np.random.rand(3,2)
np.random.randn(3,2)
np.random.randint(0,10,5)</code></pre>
        <div class="muted">Extra example — reshape</div>
        <pre><code>arr = np.arange(1,10).reshape(3,3)</code></pre>
      </div>
    </section>

    <section id="s5">
      <h2>5. Array attributes: shape, dtype, ndim, size, itemsize</h2>
      <p>Useful metadata every ndarray has:</p>
      <pre><code>a = np.array([[1,2,3],[4,5,6]], dtype=np.int64)
print(a.shape)   # (2,3)
print(a.ndim)    # 2
print(a.size)    # 6  (total elements)
print(a.dtype)   # int64
print(a.itemsize) # bytes per element (8 for int64)</code></pre>
      <div class="tip">Common pitfall: creating arrays from mixed types triggers upcasting (e.g., ints + floats &rarr; float; mixing strings &rarr; string dtype).</div>
    </section>

    <section id="s6">
      <h2>6. Vector / Matrix / Tensor — conceptual differences</h2>
      <p>Shapes map to concepts:</p>
      <ul>
        <li><strong>Vector</strong>: 1D, e.g. shape <code>(n,)</code></li>
        <li><strong>Matrix</strong>: 2D, e.g. shape <code>(m,n)</code></li>
        <li><strong>Tensor</strong>: n-dimensional (n &gt;= 3), e.g. images, batches of matrices</li>
      </ul>
      <pre><code>v = np.array([3,5,7])
M = np.array([[1,2],[3,4]])
T = np.zeros((2,3,4))</code></pre>
    </section>

    <section id="s7">
      <h2>7. Indexing &amp; Slicing (1D, 2D, 3D)</h2>
      <p><strong>1D</strong> — standard Python-like indexing & slicing:</p>
      <pre><code>v = np.array([10,20,30,40,50])
print(v[0], v[-1])
print(v[1:4])
print(v[:3], v[3:])</code></pre>

      <p><strong>2D</strong> — row, column indexing:</p>
      <pre><code>m = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(m[0,1])   # 2
print(m[1])     # [4,5,6]
print(m[:,2])   # [3,6,9]</code></pre>

      <p><strong>Slices are usually <em>views</em></strong> (not copies): modifying them can change the original array. Use <code>.copy()</code> to create an independent array.</p>
      <pre><code>sub = m[0:2,0:2]
sub[0,0] = 999   # changes original m unless you used .copy()</code></pre>

      <p><strong>3D</strong> — think of the first axis as the outer list:</p>
      <pre><code>t = np.arange(24).reshape(2,3,4)  # shape (2,3,4)
# element access:
t[0,1,2]</code></pre>
      <div class="tip">Mini-exercise: Given <code>a = np.arange(16).reshape(4,4)</code>, the bottom-right 2×2 block is <code>a[2:4, 2:4]</code>.</div>
    </section>

    <section id="s8">
      <h2>8. Boolean masking &amp; filtering</h2>
      <p>Use boolean conditions to create masks and filter arrays:</p>
      <pre><code>x = np.array([1,5,3,7,2])
mask = x > 3
print(x[mask])    # [5,7]
# one-liner
print(x[x % 2 == 0])  # even numbers</code></pre>
      <p>Combine conditions with <code>&amp;</code> (and) and <code>|</code> (or). Always parenthesize the conditions.</p>
      <pre><code>x[(x &gt; 2) &amp; (x &lt; 7)]</code></pre>
      <div class="example">
        <div class="muted">Filter rows in a 2D array where the first column &gt; 5:</div>
        <pre><code>M = np.array([[1,2],[8,9],[6,7]])
M[M[:,0] &gt; 5]   # -> [[8,9],[6,7]]</code></pre>
      </div>
    </section>

    <section id="s9">
      <h2>9. Fancy indexing</h2>
      <p>Fancy indexing selects arbitrary elements using integer arrays or lists. Note: fancy indexing returns a copy.</p>
      <pre><code>arr = np.array([10,20,30,40,50])
indices = [4,1,3]
print(arr[indices])  # -> [50,20,40]

M = np.arange(12).reshape(3,4)
rows = [0,2]
cols = [1,3]
# Use np.ix_ for outer-product like selection
print(M[np.ix_(rows, cols)])</code></pre>
    </section>

    <section id="s10">
      <h2>10. Broadcasting — theory + many examples</h2>
      <p><strong>Theory</strong>: Broadcasting lets NumPy operate on arrays of different shapes by stretching size-1 dimensions. Rules:</p>
      <ol>
        <li>Align shapes from the right (trailing dimensions).</li>
        <li>Dimensions are compatible if equal or one of them is 1.</li>
        <li>Result shape is the maximum along aligned dimensions.</li>
      </ol>
      <div class="example">
        <div class="muted">Add a vector to each row of a matrix</div>
        <pre><code>M = np.ones((3,4)) * 10      # shape (3,4)
v = np.array([1,2,3,4])      # shape (4,)
print(M + v)                 # v broadcast to (3,4)</code></pre>

        <div class="muted">Add a column vector to each column</div>
        <pre><code>col = np.array([[1],[2],[3]])   # shape (3,1)
print(M + col)                   # col broadcast to (3,4)</code></pre>

        <div class="muted">Center rows by subtracting row means</div>
        <pre><code>A = np.random.randn(4,5)
row_means = A.mean(axis=1).reshape(-1,1)  # shape (4,1)
A_centered = A - row_means</code></pre>
      </div>
      <div class="tip">Gotcha: shapes like (3,1) and (3,) are different — use <code>[:, None]</code> or <code>.reshape()</code> to be explicit.</div>
    </section>

    <section id="s11">
      <h2>11. Universal functions (ufuncs) &amp; elementwise ops</h2>
      <p>uFuncs perform elementwise operations in C — fast and memory-efficient:</p>
      <pre><code>x = np.array([0, np.pi/2, np.pi])
print(np.sin(x))</code></pre>
      <p>Common ufuncs: <code>np.sin, np.cos, np.exp, np.log, np.sqrt</code>. Combine them freely for concise math.</p>
    </section>

    <section id="s12">
      <h2>12. Aggregation functions and axis concept</h2>
      <p>Aggregations reduce dimensions: <code>sum, mean, min, max, std, argmin, argmax</code>. Use <code>axis</code> to control the reduction.</p>
      <pre><code>A = np.arange(1,13).reshape(3,4)
print(A.sum())            # total sum
print(A.sum(axis=0))      # sum per column (shape (4,))
print(A.sum(axis=1))      # sum per row (shape (3,))</code></pre>
      <div class="tip">Tip: <code>argmax</code>/<code>argmin</code> return indices. For multidimensional arrays, combine with <code>np.unravel_index</code> to get coordinates.</div>
    </section>

    <section id="s13">
      <h2>13. Reshaping, flattening, transpose, permute axes</h2>
      <p>Reshape when the total number of elements stays the same:</p>
      <pre><code>x = np.arange(12)
x2 = x.reshape(3,4)</code></pre>
      <p>Flattening:</p>
      <pre><code>x2.ravel()   # view when possible
x2.flatten() # copy</code></pre>
      <p>Transpose &amp; permute axes:</p>
      <pre><code>x2.T    # swap axes

y = np.zeros((2,3,4))
y.transpose(1,0,2)  # rearrange axes</code></pre>
      <div class="tip">Common mistake: attempting impossible reshape sizes raises an error — check <code>.size</code> first.</div>
    </section>

    <section id="s14">
      <h2>14. Concatenation, stacking, splitting</h2>
      <p>Join arrays along an axis or create a new axis:</p>
      <pre><code>a = np.array([[1,2],[3,4]])
b = np.array([[5,6]])
np.concatenate([a,b], axis=0)  # shape (3,2)
np.stack([a,a], axis=0)  # shape (2,2,2)
np.vstack([a,b])
np.hstack([a,a])</code></pre>
      <p>Split arrays:</p>
      <pre><code>np.split(np.arange(6), [2,5])</code></pre>
      <div class="tip">Performance: avoid repeated concatenations inside loops — collect pieces and concatenate once.</div>
    </section>

    <section id="s15">
      <h2>15. Sorting, argsort, searchsorted</h2>
      <pre><code>x = np.array([3,1,2])
np.sort(x)      # returns sorted copy
x.sort()        # in-place

idx = x.argsort()
print(x[idx])

arr = np.array([1,3,4,7])
np.searchsorted(arr, 5)  # -> 3</code></pre>
    </section>

    <section id="s16">
      <h2>16. <code>np.where</code> and conditional assignment</h2>
      <p><code>np.where(condition, x, y)</code> selects between <code>x</code> and <code>y</code> per-element. With one argument, returns indices where condition is true.</p>
      <pre><code>x = np.arange(6)
np.where(x % 2 == 0, x, -x)  # positive even, negative odd

A = np.array([-1,2,-3,4])
A2 = np.where(A &lt; 0, 0, A)

np.where(A &lt; 0)  # indices of negatives</code></pre>
    </section>

    <section id="s17">
      <h2>17. Copy vs View (memory) and performance tips</h2>
      <p>Slicing usually returns a view (window into original memory). Fancy indexing returns a copy. Use <code>.copy()</code> to create an independent array.</p>
      <pre><code>x = np.arange(6)
view = x[1:4]
view[0] = 999   # x changes as well
copy = x[1:4].copy()
copy[0] = -1    # x unaffected</code></pre>
      <p>Performance tips:</p>
      <ul>
        <li>Choose appropriate <code>dtype</code> to save memory (e.g., <code>float32</code> vs <code>float64</code>).</li>
        <li>Avoid repeated <code>np.concatenate</code> in loops.</li>
        <li>Use in-place ops (<code>+=</code>, <code>*=</code>) when you don't need the original data.</li>
      </ul>
    </section>

    <section id="s18">
      <h2>18. Random numbers and reproducibility</h2>
      <p>Set seed for reproducible results:</p>
      <pre><code>np.random.seed(42)
np.random.rand(3,3)</code></pre>
      <p>Sampling with choices or probabilities:</p>
      <pre><code>np.random.choice([0,1,2,3], size=5, replace=True, p=[0.1,0.2,0.3,0.4])</code></pre>
    </section>

    <section id="s19">
      <h2>19. Linear algebra basics (dot, matmul, inverse, eig)</h2>
      <pre><code>A = np.array([[1,2],[3,4]])
b = np.array([5,6])

np.dot(A,b)      # vector result
A @ b            # same as dot
A @ A            # matrix multiply

np.linalg.inv(A)
np.linalg.solve(A, b)   # more stable than inv @ b

w, v = np.linalg.eig(A)  # eigenvalues and eigenvectors</code></pre>
      <p>Other useful routines: <code>np.linalg.svd</code>, <code>np.linalg.det</code>, <code>np.linalg.norm</code>.</p>
    </section>

    <section id="s20">
      <h2>20. Practical mini-projects &amp; exercises</h2>
      <p>These are small projects to practice applied NumPy.</p>
      <div class="example">
        <div class="muted">Exercise 1 — Image-like array (gradient)</div>
        <pre><code>img = np.zeros((100,100,3), dtype=np.uint8)
img[:, :, 0] = np.linspace(0,255,100).astype(np.uint8)[None, :]</code></pre>
        <div class="muted">Exercise 2 — Standardize dataset</div>
        <pre><code>means = X.mean(axis=0)
stdev = X.std(axis=0)
X_std = (X - means) / stdev</code></pre>
        <div class="muted">Exercise 3 — Sliding window (advanced)</div>
        <pre><code>from numpy.lib.stride_tricks import sliding_window_view
arr = np.arange(10)
windows = sliding_window_view(arr, 3)  # shape (8,3)</code></pre>
      </div>
      <div class="tip">Mini-challenge: implement a moving average without using <code>np.mean</code> (use cumulative sums).</div>
    </section>

    <section id="s21">
      <h2>21. Quick reference &amp; cheat-sheet</h2>
      <ul>
        <li><strong>Creation:</strong> <code>np.array, np.arange, np.linspace, np.zeros, np.ones, np.eye</code></li>
        <li><strong>Random:</strong> <code>np.random.rand, randn, randint, choice</code></li>
        <li><strong>Math / ufuncs:</strong> <code>np.sin, np.exp, np.log, np.sqrt</code></li>
        <li><strong>Aggregation:</strong> <code>sum, mean, std, min, max, argmax</code></li>
        <li><strong>Reshape:</strong> <code>reshape, ravel, flatten, transpose</code></li>
        <li><strong>Join / split:</strong> <code>concatenate, vstack, hstack, split</code></li>
        <li><strong>Conditional:</strong> <code>where, any, all</code></li>
        <li><strong>Linear algebra:</strong> <code>dot, @, inv, det, eig, solve</code></li>
      </ul>
    </section>

    <section id="s22">
      <h2>22. Further reading and next steps</h2>
      <ul>
        <li>Official docs: <a href="https://numpy.org/doc/" target="_blank">numpy.org/doc</a></li>
        <li>SciPy: scientific computing on top of NumPy</li>
        <li>pandas: labeled/tabular data with NumPy under the hood</li>
        <li>matplotlib / seaborn: visualization</li>
        <li>scikit-learn: machine learning tooling that uses NumPy arrays</li>
      </ul>
    </section>

    <section id="s23">
      <h2>23. Advanced NumPy Topics (stride tricks, structured arrays, broadcasting tricks)</h2>
      <p><strong>Stride tricks:</strong> create sliding windows without copies using <code>sliding_window_view</code>:</p>
      <pre><code>from numpy.lib.stride_tricks import sliding_window_view
arr = np.arange(10)
print(sliding_window_view(arr, 3))</code></pre>
      <p><strong>Structured arrays:</strong> mixed-type records (like small in-memory tables):</p>
      <pre><code>dtype = [("name", "U10"), ("age", "i4"), ("weight", "f4")]
data = np.array([("Alice",25,55.0), ("Bob",30,85.5)], dtype=dtype)
print(data['name'])</code></pre>
      <p><strong>Broadcasting tricks:</strong> use <code>np.newaxis</code> / <code>None</code> to add axes, or <code>keepdims=True</code> in reductions to preserve dims for broadcasting.</p>
    </section>

    <section id="s24">
      <h2>24. Working with real-world data (CSV, images, pandas interop)</h2>
      <p>NumPy works well with file I/O and other libs.</p>
      <pre><code># load numeric CSV (simple)
arr = np.genfromtxt('data.csv', delimiter=',', skip_header=1)

# image -> NumPy (via PIL)
from PIL import Image
img = np.array(Image.open('image.jpg'))

# interop with pandas
a = pd.read_csv('data.csv').to_numpy()</code></pre>
      <div class="tip">When working with real-world data, watch out for missing values and types — pandas is often more convenient for messy CSVs.</div>
    </section>

    <section id="s25">
      <h2>25. Performance tuning and memory efficiency</h2>
      <p>Best practices:</p>
      <ul>
        <li>Prefer vectorized ops over Python loops.</li>
        <li>Use appropriate <code>dtype</code> (e.g., <code>float32</code> when 64-bit isn't needed).</li>
        <li>Avoid unnecessary copies; be mindful if slices are views.</li>
        <li>Use in-place operators to save memory.</li>
      </ul>
      <div class="example">
        <div class="muted">Benchmark example</div>
        <pre><code>import time
x = np.random.rand(10**6)
start = time.time()
y = x * 2
print('Time:', time.time() - start)</code></pre>
      </div>
    </section>

    <section id="s26">
      <h2>26. Final challenges and projects</h2>
      <p>Capstone tasks to solidify your NumPy skills:</p>
      <ol>
        <li>Implement K-means clustering from scratch using only NumPy.</li>
        <li>Build linear regression (normal equation) and compare with scikit-learn.</li>
        <li>Simulate Conway's Game of Life using NumPy slicing and boolean ops.</li>
        <li>Implement 2D convolution (image blur) using <code>sliding_window_view</code> or manual strides.</li>
      </ol>
      <div class="tip">Want solutions or starter code for any of these? Ask and I’ll provide step-by-step implementations.</div>
    </section>

    <footer>
      <p class="muted">Generated: Full HTML tutorial for NumPy (Sections 1–26). You can copy this HTML into a file <code>numpy_tutorial.html</code> and open it in your browser. Want a downloadable file or a PDF export? Tell me and I will prepare it.</p>
    </footer>
  </div>
<script>
    function toggleTheme() {
      const body = document.body;
      const btn = document.querySelector('.toggle-btn');
      if (body.getAttribute('data-theme') === 'dark') {
        body.removeAttribute('data-theme');
        btn.textContent = '🌙 Dark';
      } else {
        body.setAttribute('data-theme', 'dark');
        btn.textContent = '☀️ Light';
      }
    }
</script>
</body>
</html>
